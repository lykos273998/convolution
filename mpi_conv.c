#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <mpi.h>


#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif

#define I_AM_MASTER myid==0



// =============================================================
//  utilities for managinf pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//
// =============================================================

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------
     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY
     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i+= 1 )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}


void get_MEAN_kernel(float* kernel, unsigned int kernel_size){
    float cc = 1./(kernel_size*kernel_size);
    for(int i = 0; i<kernel_size; i++){
        for(int j = 0; j<kernel_size; j++){
            kernel[i*kernel_size+j] = cc;
        }
    }
}

float gauss(float x, float y, float sigma){
    return exp(-(x*x + y*y)/(2*sigma*sigma))/(sigma*pow(2*M_PI,0.5));
}

void get_GAUSSIAN_kernel(float* kernel, unsigned int kernel_size){
    float sum = 0;
    for(int i = 0; i < kernel_size; i++){
        for(int j = 0; j < kernel_size; j++){
            int x = j - kernel_size/2;
            int y = i - kernel_size/2;
            kernel[i*kernel_size + j] = gauss(x,y,kernel_size/2.);
            sum+= kernel[i*kernel_size+j];
        }
    }
    float cc = 0;
    for(int i = 0; i < kernel_size; i++){
        for(int j = 0; j < kernel_size; j++){
            
            kernel[i*kernel_size + j] = kernel[i*kernel_size+j]/sum;
            cc += kernel[i*kernel_size + j];
            
        }
    }
   // printf("normalization is %f \n", cc);
}

void get_SHARPEN_kernel(float* kernel, unsigned int kernel_size){
    kernel[0] = 0.;
    kernel[1] = -1.;
    kernel[2] = 0.;
    kernel[3] = -1.;
    kernel[4] = 5.;
    kernel[5] = -1.;
    kernel[6] = 0.;
    kernel[7] = -1.;
    kernel[8] = 0;
    
}

void get_start_position(int nrows, int myid, int numprocs, int kernel_size, int* start, int* d){
  
  int dim = ( nrows / numprocs );
    int start_position = dim*myid;
    int s = kernel_size/2;
    if(nrows % numprocs > myid){
      start_position += myid;
    }
    else{
      start_position+=nrows % numprocs;
    }

    if(myid == 0 || myid == numprocs - 1){
      dim += s;
    }
    else{
      dim+=2*s;
    }
    *start = start_position;
    *d = dim;

}
int main(int argc, char**argv){
    
    if(argc < 3){
        printf("usage: \n ./executable KERNEL_TYPE<0,1,..> KERNEL_SIZE INPUT_FILE \n ---PGM FILES ALLOWED ONLY--- \n");
        return 0;
    }

    MPI_Init(&argc, &argv);
    MPI_Status status;
    MPI_Request request;
    //get the id
    int myid, numprocs;
    int tag = 123;
    int master = 0;
    MPI_Comm_rank(MPI_COMM_WORLD, &myid);
    MPI_Comm_size(MPI_COMM_WORLD,&numprocs);
    //each process needs his own kernel 

    unsigned short int kernel_type;
    unsigned int kernel_size;
    float* kernel;
    char* input_file, *out_file; 

    kernel_type = atoi(argv[1]);
    kernel_size = atoi(argv[2]);

    if(kernel_size%2 == 0){
        if (myid==0) printf("Please insert an odd kernel size!\n");
        MPI_Finalize();
        return 0;
    }
    input_file = argv[3];
    out_file = "out.pgm";
    if (argc > 4){out_file = argv[4];}
    kernel = (float*)malloc(kernel_size*kernel_size*sizeof(float));
    switch (kernel_type){
        case 0:
        //mean kernel
        get_MEAN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected MEAN kernel \n");
        break;

        case 1:
        //gaussian kernel
        get_GAUSSIAN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected GAUSSIAN kernel \n");
        break;

        case 2:
        //sharpen kernel
        kernel_size = 3;
        free(kernel);
        kernel = (float*)malloc(kernel_size*kernel_size*sizeof(float));
        get_SHARPEN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected SHARPEN kernel \n ATTENTION FOR THIS KERNEL kernel_size BOUDNED TO 3 \n");
        break;


        default:
        if(myid == 0){
        printf("Unknown kernel\nThis is the list of Implemented kernels: \n");
        printf("0 --> Mean Kernel \n");
        printf("1 --> Gaussian Kernel \n");
        printf("2 --> Sharpening Kernel \n");
        printf("+ others will be added developement\n");
        }
        MPI_Finalize();
        return 0;

    }

    //printf("---KERNEL---\n");
    //print_kernel(kernel,kernel_size);
    
    void* source;
    int maxval, nrows, ncols;
    int metadata[3];
    if(I_AM_MASTER){
    
      read_pgm_image(&source, &maxval, &ncols, &nrows, input_file);
      if ( I_M_LITTLE_ENDIAN ) swap_image( source, ncols, nrows, maxval);
      metadata[0] = maxval;
      metadata[1] = nrows;
      metadata[2] = ncols;

    }

    MPI_Bcast(metadata,3, MPI_INT, 0, MPI_COMM_WORLD);
    maxval = metadata[0];
    nrows = metadata[1];
    ncols = metadata[2];
    
    
   
    int start_position, dim;
    get_start_position(nrows, myid, numprocs, kernel_size, &start_position, &dim);
    int s = kernel_size/2;
    
    //printf("%d id %d\n", myid, start_position);
    
    if(I_AM_MASTER){
      //unsigned char m = 3;
      int m = 3;
      for(int p = 1; p < numprocs; p++){
      MPI_Send(&m, 1, MPI_INT,p, tag, MPI_COMM_WORLD );
      }

    }
    else
    {
      //unsigned char m;
      int m = 0;
      MPI_Recv(&m, 1, MPI_INT, master, tag, MPI_COMM_WORLD, &status);
      //printf("%d %d \n", myid, m);
    }
  



    /*
    switch (1 + (maxval > 255))
    {
    case 1:
        {
        unsigned char* result = (unsigned char*)malloc(nrows*ncols*sizeof(unsigned char));
        convolve_1B((unsigned char* )source,nrows,ncols,kernel,kernel_size,result);
        if ( I_M_LITTLE_ENDIAN ) swap_image( result, ncols, nrows, maxval); 
        write_pgm_image(result, maxval, ncols, nrows, out_file);
        free(result);
        break;
        }

    case 2:
        {
        unsigned short int* result = (unsigned short int*)malloc(nrows*ncols*sizeof(unsigned short int));
        convolve_2B((unsigned short int* )source,nrows,ncols,kernel,kernel_size,result);
        if ( I_M_LITTLE_ENDIAN ) swap_image( result, ncols, nrows, maxval); 
        write_pgm_image(result, maxval, ncols, nrows, out_file);
        free(result);
        break;
        }
    default:
        return 0;
        printf("Something went wrong aborting\n");
        break;
    }
    */
    
    free(kernel);
    free(source);
    MPI_Finalize();
    return 0;
    
}


