#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <mpi.h>


#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif

#define I_AM_MASTER myid==0



// =============================================================
//  utilities for managinf pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//
// =============================================================

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------
     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY
     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i+= 1 )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}


void get_MEAN_kernel(double* kernel, unsigned int kernel_size){
    double cc = 1./(kernel_size*kernel_size);
    for(int i = 0; i<kernel_size; i++){
        for(int j = 0; j<kernel_size; j++){
            kernel[i*kernel_size+j] = cc;
        }
    }
}

double gauss(double x, double y, double sigma){
    return exp(-(x*x + y*y)/(2*sigma*sigma))/(sigma*pow(2*M_PI,0.5));
}

void get_GAUSSIAN_kernel(double* kernel, unsigned int kernel_size){
    double sum = 0;
    for(int i = 0; i < kernel_size; i++){
        for(int j = 0; j < kernel_size; j++){
            int x = j - kernel_size/2;
            int y = i - kernel_size/2;
            kernel[i*kernel_size + j] = gauss(x,y,kernel_size/2.);
            sum+= kernel[i*kernel_size+j];
        }
    }
    double cc = 0;
    for(int i = 0; i < kernel_size; i++){
        for(int j = 0; j < kernel_size; j++){
            
            kernel[i*kernel_size + j] = kernel[i*kernel_size+j]/sum;
            cc += kernel[i*kernel_size + j];
            
        }
    }
   // //printf("normalization is %f \n", cc);
}

void get_WEIGHT_kernel(double* kernel, unsigned int kernel_size, double w){
    double other = (1.0 - w)/(kernel_size * kernel_size  - 1);
    int s = kernel_size/2;
    for(int i = 0; i < kernel_size; i++){
        for(int j = 0; j < kernel_size; j++){
            
            kernel[i*kernel_size + j] = other;
        }
    }
    kernel[s*kernel_size + s] = w;
    
   // //printf("normalization is %f \n", cc);
}




void get_SHARPEN_kernel(double* kernel, unsigned int kernel_size){
    kernel[0] = 0.;
    kernel[1] = -1.;
    kernel[2] = 0.;
    kernel[3] = -1.;
    kernel[4] = 5.;
    kernel[5] = -1.;
    kernel[6] = 0.;
    kernel[7] = -1.;
    kernel[8] = 0;
    
}





void get_start_position(int nrows, int myid, int numprocs, int kernel_size, int* start, int* d){
  
  int dim = ( nrows / numprocs );
  int start_position = dim*myid;
  int s = kernel_size/2;

    if(nrows % numprocs > myid){
      start_position += myid;
      dim += 1;
    }
    else{
      start_position += nrows % numprocs;
    }

    if(myid == 0 || myid == numprocs - 1){
      dim += s;
    }
    else{
      dim += 2*s;
    }
    
    *start = start_position - s*(myid > 0);
    *d = dim;

}




void convolve_1B(unsigned char * source,int nrows,int ncols,double * kernel, int kernel_size, unsigned char *result){
    
    ////printf("S %d \n", s);
    
    //interior convolution

    #pragma omp parallel 
    {
    int k_i_start, k_i_end, k_j_start, k_j_end, img_index, res_index, k_index;
    double tmp;
    int s = kernel_size/2;
    
    ////printf("Processing Interior\n");
    //int ns = nrows/omp_get_num_threads();
    int ns = s + 1;
    int remainder = nrows - s - ((nrows - 2*s) % ns);
    ////printf("remainder %d", (remainder - s)%ns);
    ////printf("Processing Interior\n");
    #pragma omp for nowait
    for(int cc = s; cc < remainder; cc+=ns){    
        for(int i = cc; i < cc+ns; i++){
            for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            double tmp = 0.;
        //single element
        for (int k_i = 0; k_i < kernel_size; k_i ++ ){
        for (int k_j = 0; k_j < kernel_size; k_j ++ ){  
            k_index = k_i * kernel_size + k_j;
            size_t img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
            tmp += (double)source[img_index]*kernel[k_index];
            
            
        }
        }
            result[res_index] = (unsigned char)tmp;
           // //printf("%f ", tmp);


    }  
    }
    }
    
    
    //double tmp = 0.;
    
    //remainder
    #pragma omp for schedule(dynamic,ns) nowait
        for(int i = remainder; i < nrows - s; i++){
                for(int j = s; j < ncols - s; j++){
                    res_index = i*ncols + j;
                    result[res_index] = 0;
                    tmp = 0.;
                    //single element
                    for (int k_i = 0; k_i < kernel_size; k_i ++ ){
                    for (int k_j = 0; k_j < kernel_size; k_j ++ ){  
                        k_index = k_i * kernel_size + k_j;
                        img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                        tmp+= kernel[k_index]*source[img_index];
                    }
                    }
                    result[res_index] = tmp;
    }
    }
    
    
    //img_index, k_index, res_index;
    //halo up
    ////printf("Processing HALO UP\n");
    
    
    
    ////printf("Processing HALO UP\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i <s; i++){
        for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }
    //halo down
    
    
    
    ////printf("Processing HALO DOWN\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows - i);
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                
                tmp += kernel[k_index]*(double)source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    

    //halo left
    
    #pragma omp for schedule(dynamic,ns) nowait
    ////printf("Processing HALO LEFT\n");
    for(int i = s; i < nrows - s; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = kernel_size;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    
    //halo right
    
    
    ////printf("Processing HALO RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = s; i < nrows - s; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s + ncols - j;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){   
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    
    
    
    
    ////printf("Processing Q UP LEFT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    

   
    ////printf("Processing Q UP RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i < s; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s + (ncols - j);
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    

    
    ////printf("Processing Q DOWN LEFT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows -i);
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*(double)source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    

    

    ////printf("Processing Q DOWN RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows - i);
            k_j_start = 0;
            k_j_end = s + (ncols - j);
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*(double)source[img_index];
            }
            }
            result[res_index] = tmp;

        }
    }  
    

    
    
    }
    ////printf("Processing finished successfully!\n");
}

void convolve_2B(unsigned short int* source,int nrows,int ncols,double * kernel, int kernel_size, unsigned short int* result){
    
    ////printf("S %d \n", s);
    
    //interior convolution

    #pragma omp parallel 
    {
    int k_i_start, k_i_end, k_j_start, k_j_end, img_index, res_index, k_index;
    double tmp;
    int s = kernel_size/2;
    
    ////printf("Processing Interior\n");
    //int ns = nrows/omp_get_num_threads();
    int ns = s + 1;
    int remainder = nrows - s - ((nrows - 2*s) % ns);
    ////printf("remainder %d", (remainder - s)%ns);
    ////printf("Processing Interior\n");
    #pragma omp for nowait
    for(int cc = s; cc < remainder; cc+=ns){    
        for(int i = cc; i < cc+ns; i++){
            for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            double tmp = 0.;
        //single element
        for (int k_i = 0; k_i < kernel_size; k_i ++ ){
        for (int k_j = 0; k_j < kernel_size; k_j ++ ){  
            k_index = k_i * kernel_size + k_j;
            size_t img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
            tmp += (double)source[img_index]*kernel[k_index];
            
            
        }
        }
            result[res_index] = (unsigned short)tmp;
           // //printf("%f ", tmp);


    }  
    }
    }
    
    
    //double tmp = 0.;
    
    //remainder
    #pragma omp for schedule(dynamic,ns) nowait
        for(int i = remainder; i < nrows - s; i++){
                for(int j = s; j < ncols - s; j++){
                    res_index = i*ncols + j;
                    result[res_index] = 0;
                    tmp = 0.;
                    //single element
                    for (int k_i = 0; k_i < kernel_size; k_i ++ ){
                    for (int k_j = 0; k_j < kernel_size; k_j ++ ){  
                        k_index = k_i * kernel_size + k_j;
                        img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                        tmp+= kernel[k_index]*source[img_index];
                    }
                    }
                    result[res_index] = tmp;
    }
    }
    
    
    //img_index, k_index, res_index;
    //halo up
    ////printf("Processing HALO UP\n");
    
    
    
    ////printf("Processing HALO UP\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i <s; i++){
        for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }
    //halo down
    
    
    
    ////printf("Processing HALO DOWN\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = s; j < ncols - s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows - i);
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                size_t img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*(double)source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    //halo left
    
    #pragma omp for schedule(dynamic,ns) nowait
    ////printf("Processing HALO LEFT\n");
    for(int i = s; i < nrows - s; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = kernel_size;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    //halo right
    
    
    ////printf("Processing HALO RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = s; i < nrows - s; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s + ncols - j;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){   
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    
    
    
    ////printf("Processing Q UP LEFT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
   
    ////printf("Processing Q UP RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = 0; i < s; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = s - i;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s + (ncols - j);
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp+= kernel[k_index]*source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    
    ////printf("Processing Q DOWN LEFT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = 0; j < s; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows -i);
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){ 
                k_index = k_i * kernel_size + k_j;
                size_t img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                tmp += kernel[k_index]*(double)source[img_index];
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    
    ////printf("Processing Q DOWN RIGHT\n");
    #pragma omp for schedule(dynamic,ns) nowait
    for(int i = nrows - s; i < nrows; i++){
        for(int j = ncols - s; j < ncols; j++){
            res_index = i*ncols + j;
            result[res_index] = 0;
            //single element
            k_i_start = 0;
            k_i_end = s + (nrows - i);
            k_j_start = 0;
            k_j_end = s + (ncols - j);
            tmp = 0.;
            //single element
            for (int k_i = k_i_start; k_i < k_i_end; k_i ++ ){
            for (int k_j = k_j_start; k_j < k_j_end; k_j ++ ){  
                k_index = k_i * kernel_size + k_j;
                img_index = (i + (k_i - s))*ncols + (j + (k_j - s));
                double c1 = kernel[k_index];
                double c2 = source[img_index];
                tmp += c1*c2;
            }
            }
            result[res_index] = tmp;
        }
    }  
    
    
    }
    //printf("Processing finished successfully!\n");
}


void sub_matrix_dim(int nrows, int ncols, int *proc_dim, int *proc_coord, int *sub_mat_sizes, int *start_point){
    sub_mat_sizes[0] = nrows/ proc_dim[0];
    sub_mat_sizes[1] = ncols / proc_dim[1];

    start_point[0] = sub_mat_sizes[0] * proc_coord[0];
    start_point[1] = sub_mat_sizes[1] * proc_coord[1];

    if(proc_coord[0] < nrows% proc_dim[0] ){
        sub_mat_sizes[0] += 1;
        start_point[0] += (proc_coord[0]);
    }
    else{
       start_point[0] += nrows% proc_dim[0];
    }

    if(proc_coord[1] < ncols % proc_dim[1] ){
        sub_mat_sizes[1] += 1;
        start_point[1] += (proc_coord[1]);
    }
    else{
       start_point[1] += ncols% proc_dim[1];
    }
}


void exchange_halos_2B(unsigned short* my_img,int* my_img_dims, unsigned short** halos, int* grid_dims, int my_rank, int* grid_coords, int kernel_size, MPI_Comm mpi_communicator){
    unsigned short* halo_up, *halo_down, *halo_right, *halo_left;
    int s = kernel_size/2;
    /*
    halo_up = halos[0];
    halo_right = halos[1];
    halo_down = halos[2];
    halo_left = halos[3];
    */
    MPI_Datatype HALO;
    int y = grid_coords[0];
    int x = grid_coords[1];
    int nrows = my_img_dims[0];
    int ncols = my_img_dims[1];
    int rl, rr, ru, rd;
    MPI_Status status;
    MPI_Request request;
    MPI_Cart_shift(mpi_communicator, 0, 1, &ru, &rd);
    MPI_Cart_shift(mpi_communicator, 1, 1, &rl, &rr);
    ////printf("rank %d  nb rl %d rr %d ru %d rd %d cc %d %d \n", my_rank, rl, rr, ru, rd, grid_coords[0], grid_coords[1]);
    //halo up-down exchange

    //send halo up and recieve down
    int tag = 117;
    if(ru >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = s;
        halo_dims[1] = ncols;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, ru, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1){
        halo_down = NULL;
        }
    else{
        halo_down = (unsigned short*)malloc(sizeof(unsigned short)* s*ncols);
        MPI_Recv(halo_down, s*ncols, MPI_UNSIGNED_SHORT, rd, tag, mpi_communicator, &status);  
        }

    if(rd >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = s;
        halo_dims[1] = ncols;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rd , rd, mpi_communicator, &request);
        
        
    }
    if(y == 0){
        halo_up = NULL;
        }
    else{
        halo_up = (unsigned short*)malloc(sizeof(unsigned short)* s*ncols);
        MPI_Recv(halo_up, s*ncols, MPI_UNSIGNED_SHORT, ru, my_rank, mpi_communicator, &status);  
        }



    if(rr >= 0 ){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = ncols - s;
        int halo_dims[2];
        halo_dims[0] = nrows;
        halo_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rr , rr, mpi_communicator, &request);
        
        
    }
    if(x == 0){
        halo_left = NULL;
        }
    else{
        halo_left = (unsigned short*)malloc(sizeof(unsigned short)* s*nrows);
        MPI_Recv(halo_left, s*nrows, MPI_UNSIGNED_SHORT, rl, my_rank, mpi_communicator, &status)  ;
        }


    
    if(rl >= 0 ){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = nrows;
        halo_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rl , rl, mpi_communicator, &request);
        
        
    }
    if(x == grid_dims[1] - 1){
        halo_right = NULL;
        }
    else{
        halo_right = (unsigned short*)malloc(sizeof(unsigned short)* s*nrows);
        MPI_Recv(halo_right, s*nrows, MPI_UNSIGNED_SHORT, rr, my_rank, mpi_communicator, &status) ; 
        }


    //returning the pointers
    halos[0] = halo_up;
    halos[1] = halo_right;
    halos[2] = halo_down;
    halos[3] = halo_left;
    
}


void exchange_Q_2B(unsigned short* my_img,int* my_img_dims, unsigned short** squares, int* grid_dims, int my_rank, int* grid_coords, int kernel_size, MPI_Comm mpi_communicator){
    
    unsigned short * QUL, *QUR, *QDL, *QDR;

    int y = grid_coords[0];
    int x = grid_coords[1];
    int nrows = my_img_dims[0];
    int ncols = my_img_dims[1];
    int s = kernel_size/2;
    int tag = 123;
    int r_ul, r_ur, r_dl, r_dr;
    r_ul = -2;
    r_ur = -2;
    r_dr = -2;
    r_dl = -2;

    int up, down, left, right;
    MPI_Status status;
    MPI_Request request;
    MPI_Datatype QQ;
    
    MPI_Cart_shift(mpi_communicator, 0, 1, &up, &down);
    MPI_Cart_shift(mpi_communicator, 1, 1, &left, &right);
    //calculating neighbours  -2 is the code fore being at the boundary in some way
    if(up >= 0) {
        if(left >= 0) {r_ul = up - 1; }
        else if (right >=0) {r_ur = up + 1; }
        else{}
    }
    if(down >= 0) {
        if(left >= 0) {r_dl = down - 1; }
        else if (right >=0) {r_dr = down + 1; }
        else{}
    }
    ////printf("rank %d  nb r_ul %d r_ur %d r_dr %d r_dl %d cc %d %d \n", my_rank, r_ul, r_ur, r_dr, r_dl, grid_coords[0], grid_coords[1]);
    //another time this is the foolish part
    
    if(r_ul >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_ul, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1 || x == grid_dims[1] - 1){
        QDR = NULL;
        }
    else{
        QDR = (unsigned short*)malloc(sizeof(unsigned short)*s*s);
        MPI_Recv(QDR,s*s, MPI_UNSIGNED_SHORT, r_dr, tag,mpi_communicator,&status );
    }

    if(r_ur >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = ncols - s;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_ur, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1 || x == 0){
        QDL = NULL;
        }
    else{
        QDL = (unsigned short*)malloc(sizeof(unsigned short)*s*s);
        MPI_Recv(QDL,s*s, MPI_UNSIGNED_SHORT, r_dl, tag,mpi_communicator, &status );
    }


    if(r_dr >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = ncols - s;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_dr, tag, mpi_communicator, &request);
        
        
    }
    if(y == 0 || x == 0){
        QUL = NULL;
        }
    else{
        QUL = (unsigned short*)malloc(sizeof(unsigned short)*s*s);
        MPI_Recv(QUL,s*s, MPI_UNSIGNED_SHORT, r_ul, tag,mpi_communicator,&status );
    }

    if(r_dl >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = 0;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_dl, tag, mpi_communicator, &request);
        
        
    }
    if(y == 0 || x == grid_dims[1] - 1){
        QUR = NULL;
        }
    else{
        QUR = (unsigned short*)malloc(sizeof(unsigned short)*s*s);
        MPI_Recv(QUR,s*s, MPI_UNSIGNED_SHORT, r_ur, tag,mpi_communicator, &status );
    }
    
    squares[0] = QUL;
    squares[1] = QUR;
    squares[2] = QDR;
    squares[3] = QDL;



}

void QQ_convolve_2B(unsigned short** QQ, unsigned short** HALOS, int* sub_matrix_sizes, double* kernel, int kernel_size, unsigned short* res){
    int s = kernel_size/2;
    int nrows = sub_matrix_sizes[0];
    int ncols = sub_matrix_sizes[1];
    int k_i_start;
    int k_i_end;
    int k_j_start;
    int k_j_end;
    double tmp ;
    int res_index, img_index, kernel_index;

    unsigned short * halo_up = HALOS[0];
    unsigned short * halo_right = HALOS[1];
    unsigned short * halo_down = HALOS[2];
    unsigned short * halo_left = HALOS[3];

    unsigned short * QUL = QQ[0];
    unsigned short * QUR = QQ[1];
    unsigned short * QDR = QQ[2];
    unsigned short * QDL = QQ[3];
    ////printf("hh %p %p %p %p\n", halo_up, halo_right, halo_down, halo_left);
   // //printf("qq %p %p %p %p\n", QUL, QUR, QDR, QDL);   //halo up
    
    
    if(QUL!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = s - j;
            tmp = 0.;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (i + k_i)*s + (j + k_j);
                    tmp += kernel[kernel_index] * QUL[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }

    if(QUR!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = kernel_size - j - 1;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = (i)*ncols + j + ncols - s;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (i + k_i)*s + (kernel_size - k_j + 1);
                    
                    tmp += kernel[kernel_index] * QUR[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }


    if(QDR!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = kernel_size - i - 1;
            k_i_end = kernel_size;
            k_j_start = kernel_size - j - 1;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = (i + nrows - s)*ncols + j + ncols - s;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (kernel_size - k_i + 1)*s + (kernel_size - k_j + 1);
                    
                    tmp += kernel[kernel_index] * QDR[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }

    
    if(QDL!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = kernel_size - i - 1;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s - j;
            tmp = 0.0;
            res_index = (i + nrows - s)*ncols + j ;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (kernel_size - k_i + 1)*s + (j + k_j);
                    
                    tmp += kernel[kernel_index] * QDL[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }     
    

}

void halo_convolve_2B(unsigned short** HALOS, int* sub_matrix_sizes, double* kernel, int kernel_size, unsigned short* res){
    int s = kernel_size/2;
    int nrows = sub_matrix_sizes[0];
    int ncols = sub_matrix_sizes[1];
    int k_i_start;
    int k_i_end;
    int k_j_start;
    int k_j_end;
    double tmp ;
    int res_index, img_index, kernel_index;
    unsigned short * halo_up = HALOS[0];
    unsigned short * halo_right = HALOS[1];
    unsigned short * halo_down = HALOS[2];
    unsigned short * halo_left = HALOS[3];

    
    //halo up
    if(halo_up!=NULL){
        for(int i = 0; i < s; i++){
        for (int j = 0; j < s; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - s);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;  
        }
        for(int j = s; j < ncols - s; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - s);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;


        }
        for (int j = ncols - s; j < ncols; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = kernel_size - (j - (ncols - s));
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - k_j_end);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;  
        }
        }
    }
  //halo down
    if(halo_down!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = s - j;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;
            }
            for(int j = s; j < ncols - s; j++){

                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;


            }
            
            for(int j = ncols - s; j < ncols; j++){
                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = kernel_size - j + ncols - s;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;
            }
            
        }
    }

    //halo right

    if(halo_right!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = s - i;
                k_i_end = kernel_size;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
               res[res_index] += tmp;


            }
        }
        for(int i = s; i < nrows - s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
                res[res_index] += tmp;


            }

        }
        for(int i = nrows - s; i < nrows; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size - i + nrows - s;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
    }

    if(halo_left!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = s - i;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
        for(int i = s; i < nrows - s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
        for(int i = nrows - s; i < nrows; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size - i + nrows - s;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
    }





}





void exchange_halos_1B(unsigned char* my_img,int* my_img_dims, unsigned char** halos, int* grid_dims, int my_rank, int* grid_coords, int kernel_size, MPI_Comm mpi_communicator){
    unsigned char* halo_up, *halo_down, *halo_right, *halo_left;
    int s = kernel_size/2;
    /*
    halo_up = halos[0];
    halo_right = halos[1];
    halo_down = halos[2];
    halo_left = halos[3];
    */
    MPI_Datatype HALO;
    int y = grid_coords[0];
    int x = grid_coords[1];
    int nrows = my_img_dims[0];
    int ncols = my_img_dims[1];
    int rl, rr, ru, rd;
    MPI_Status status;
    MPI_Request request;
    MPI_Cart_shift(mpi_communicator, 0, 1, &ru, &rd);
    MPI_Cart_shift(mpi_communicator, 1, 1, &rl, &rr);
    ////printf("rank %d  nb rl %d rr %d ru %d rd %d cc %d %d \n", my_rank, rl, rr, ru, rd, grid_coords[0], grid_coords[1]);
    //halo up-down exchange

    //send halo up and recieve down
    int tag = 117;
    if(ru >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = s;
        halo_dims[1] = ncols;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, ru, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1){
        halo_down = NULL;
        }
    else{
        halo_down = (unsigned char*)malloc(sizeof(unsigned char)* s*ncols);
        MPI_Recv(halo_down, s*ncols, MPI_UNSIGNED_CHAR, rd, tag, mpi_communicator, &status);  
        }

    if(rd >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = s;
        halo_dims[1] = ncols;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rd , rd, mpi_communicator, &request);
        
        
    }
    if(y == 0){
        halo_up = NULL;
        }
    else{
        halo_up = (unsigned char*)malloc(sizeof(unsigned char)* s*ncols);
        MPI_Recv(halo_up, s*ncols, MPI_UNSIGNED_CHAR, ru, my_rank, mpi_communicator, &status);  
        }



    if(rr >= 0 ){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = ncols - s;
        int halo_dims[2];
        halo_dims[0] = nrows;
        halo_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rr , rr, mpi_communicator, &request);
        
        
    }
    if(x == 0){
        halo_left = NULL;
        }
    else{
        halo_left = (unsigned char*)malloc(sizeof(unsigned char)* s*nrows);
        MPI_Recv(halo_left, s*nrows, MPI_UNSIGNED_CHAR, rl, my_rank, mpi_communicator, &status)  ;
        }


    
    if(rl >= 0 ){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int halo_dims[2];
        halo_dims[0] = nrows;
        halo_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, halo_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &HALO);
        MPI_Type_commit(&HALO);
        MPI_Isend(my_img, 1, HALO, rl , rl, mpi_communicator, &request);
        
        
    }
    if(x == grid_dims[1] - 1){
        halo_right = NULL;
        }
    else{
        halo_right = (unsigned char*)malloc(sizeof(unsigned char)* s*nrows);
        MPI_Recv(halo_right, s*nrows, MPI_UNSIGNED_CHAR, rr, my_rank, mpi_communicator, &status) ; 
        }


    //returning the pointers
    halos[0] = halo_up;
    halos[1] = halo_right;
    halos[2] = halo_down;
    halos[3] = halo_left;
    
}


void exchange_Q_1B(unsigned char* my_img,int* my_img_dims, unsigned char** squares, int* grid_dims, int my_rank, int* grid_coords, int kernel_size, MPI_Comm mpi_communicator){
    
    unsigned char * QUL, *QUR, *QDL, *QDR;

    int y = grid_coords[0];
    int x = grid_coords[1];
    int nrows = my_img_dims[0];
    int ncols = my_img_dims[1];
    int s = kernel_size/2;
    int tag = 123;
    int r_ul, r_ur, r_dl, r_dr;
    r_ul = -2;
    r_ur = -2;
    r_dr = -2;
    r_dl = -2;

    int up, down, left, right;
    MPI_Status status;
    MPI_Request request;
    MPI_Datatype QQ;
    
    MPI_Cart_shift(mpi_communicator, 0, 1, &up, &down);
    MPI_Cart_shift(mpi_communicator, 1, 1, &left, &right);
    //calculating neighbours  -2 is the code fore being at the boundary in some way
    if(up >= 0) {
        if(left >= 0) {r_ul = up - 1; }
        else if (right >=0) {r_ur = up + 1; }
        else{}
    }
    if(down >= 0) {
        if(left >= 0) {r_dl = down - 1; }
        else if (right >=0) {r_dr = down + 1; }
        else{}
    }
    ////printf("rank %d  nb r_ul %d r_ur %d r_dr %d r_dl %d cc %d %d \n", my_rank, r_ul, r_ur, r_dr, r_dl, grid_coords[0], grid_coords[1]);
    //another time this is the foolish part
    
    if(r_ul >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = 0;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_ul, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1 || x == grid_dims[1] - 1){
        QDR = NULL;
        }
    else{
        QDR = (unsigned char*)malloc(sizeof(unsigned char)*s*s);
        MPI_Recv(QDR,s*s, MPI_UNSIGNED_CHAR, r_dr, tag,mpi_communicator,&status );
    }

    if(r_ur >= 0){
        int start_point[2];
        start_point[0] = 0;
        start_point[1] = ncols - s;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_ur, tag, mpi_communicator, &request);
        
        
    }
    if(y == grid_dims[0]-1 || x == 0){
        QDL = NULL;
        }
    else{
        QDL = (unsigned char*)malloc(sizeof(unsigned char)*s*s);
        MPI_Recv(QDL,s*s, MPI_UNSIGNED_CHAR, r_dl, tag,mpi_communicator, &status );
    }


    if(r_dr >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = ncols - s;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_dr, tag, mpi_communicator, &request);
        
        
    }
    if(y == 0 || x == 0){
        QUL = NULL;
        }
    else{
        QUL = (unsigned char*)malloc(sizeof(unsigned char)*s*s);
        MPI_Recv(QUL,s*s, MPI_UNSIGNED_CHAR, r_ul, tag,mpi_communicator,&status );
    }

    if(r_dl >= 0){
        int start_point[2];
        start_point[0] = nrows - s;
        start_point[1] = 0;
        int q_dims[2];
        q_dims[0] = s;
        q_dims[1] = s;

        MPI_Type_create_subarray(2, my_img_dims, q_dims, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &QQ);
        MPI_Type_commit(&QQ);
        MPI_Isend(my_img, 1, QQ, r_dl, tag, mpi_communicator, &request);
        
        
    }
    if(y == 0 || x == grid_dims[1] - 1){
        QUR = NULL;
        }
    else{
        QUR = (unsigned char*)malloc(sizeof(unsigned char)*s*s);
        MPI_Recv(QUR,s*s, MPI_UNSIGNED_CHAR, r_ur, tag,mpi_communicator, &status );
    }
    
    squares[0] = QUL;
    squares[1] = QUR;
    squares[2] = QDR;
    squares[3] = QDL;



}

void QQ_convolve_1B(unsigned char** QQ, unsigned char** HALOS, int* sub_matrix_sizes, double* kernel, int kernel_size, unsigned char* res){
    int s = kernel_size/2;
    int nrows = sub_matrix_sizes[0];
    int ncols = sub_matrix_sizes[1];
    int k_i_start;
    int k_i_end;
    int k_j_start;
    int k_j_end;
    double tmp ;
    int res_index, img_index, kernel_index;

    unsigned char * halo_up = HALOS[0];
    unsigned char * halo_right = HALOS[1];
    unsigned char * halo_down = HALOS[2];
    unsigned char * halo_left = HALOS[3];

    unsigned char * QUL = QQ[0];
    unsigned char * QUR = QQ[1];
    unsigned char * QDR = QQ[2];
    unsigned char * QDL = QQ[3];
    ////printf("hh %p %p %p %p\n", halo_up, halo_right, halo_down, halo_left);
   // //printf("qq %p %p %p %p\n", QUL, QUR, QDR, QDL);   //halo up
    
    
    if(QUL!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = s - j;
            tmp = 0.;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (i + k_i)*s + (j + k_j);
                    tmp += kernel[kernel_index] * QUL[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }

    if(QUR!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = kernel_size - j - 1;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = (i)*ncols + j + ncols - s;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (i + k_i)*s + (kernel_size - k_j + 1);
                    
                    tmp += kernel[kernel_index] * QUR[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }


    if(QDR!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = kernel_size - i - 1;
            k_i_end = kernel_size;
            k_j_start = kernel_size - j - 1;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = (i + nrows - s)*ncols + j + ncols - s;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (kernel_size - k_i + 1)*s + (kernel_size - k_j + 1);
                    
                    tmp += kernel[kernel_index] * QDR[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }

    
    if(QDL!=NULL){
        
        for(int i = 0; i < s; i++){
        for(int j = 0; j < s; j++){
            
            res_index = i*ncols + j;
            
            k_i_start = kernel_size - i - 1;
            k_i_end = kernel_size;
            k_j_start = 0;
            k_j_end = s - j;
            tmp = 0.0;
            res_index = (i + nrows - s)*ncols + j ;

            for(int k_i = k_i_start; k_i < k_i_end; k_i++ ){
                
                for(int k_j = k_j_start; k_j < k_j_end; k_j++ ){
                    kernel_index = k_i * kernel_size + k_j;
                    img_index = (kernel_size - k_i + 1)*s + (j + k_j);
                    
                    tmp += kernel[kernel_index] * QDL[img_index];
                }
            
            }
            res[res_index] += tmp;
        }
    }
    }     
    

}

void halo_convolve_1B(unsigned char** HALOS, int* sub_matrix_sizes, double* kernel, int kernel_size, unsigned char* res){
    int s = kernel_size/2;
    int nrows = sub_matrix_sizes[0];
    int ncols = sub_matrix_sizes[1];
    int k_i_start;
    int k_i_end;
    int k_j_start;
    int k_j_end;
    double tmp ;
    int res_index, img_index, kernel_index;
    unsigned char * halo_up = HALOS[0];
    unsigned char * halo_right = HALOS[1];
    unsigned char * halo_down = HALOS[2];
    unsigned char * halo_left = HALOS[3];

    
    //halo up
    if(halo_up!=NULL){
        for(int i = 0; i < s; i++){
        for (int j = 0; j < s; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = s - j;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - s);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;  
        }
        for(int j = s; j < ncols - s; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = kernel_size;
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - s);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;


        }
        for (int j = ncols - s; j < ncols; j++){
            k_i_start = 0;
            k_i_end = s - i;
            k_j_start = 0;
            k_j_end = kernel_size - (j - (ncols - s));
            tmp = 0.0;
            res_index = i*ncols+j;
            for(int k_i = k_i_start; k_i < k_i_end; k_i++){
            for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                img_index = (i + k_i)*ncols + (j + k_j - k_j_end);
                kernel_index = k_i * kernel_size + k_j; 

                tmp+= kernel[kernel_index] * halo_up[img_index];                          
                }

            }
            res[res_index] += tmp;  
        }
        }
    }
  //halo down
    if(halo_down!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = s - j;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;
            }
            for(int j = s; j < ncols - s; j++){

                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;


            }
            
            for(int j = ncols - s; j < ncols; j++){
                k_i_start = kernel_size - i - 1;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = kernel_size - j + ncols - s;
                tmp = 0.0;
                res_index = (nrows - s + i)*ncols+j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - kernel_size + 1)*ncols + (j + k_j - s);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_down[img_index];                          
                    }

                }
                res[res_index] += tmp;
            }
            
        }
    }

    //halo right

    if(halo_right!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = s - i;
                k_i_end = kernel_size;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
               res[res_index] += tmp;


            }
        }
        for(int i = s; i < nrows - s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
                res[res_index] += tmp;


            }

        }
        for(int i = nrows - s; i < nrows; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size - i + nrows - s;
                k_j_start = kernel_size - j - 1;
                k_j_end = kernel_size;
                tmp = 0.0;
                res_index = (i)*ncols + j + ncols - s;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  + k_i - s)*s + (j + k_j - kernel_size + 1);
                    kernel_index = k_i * kernel_size + k_j; 

                    tmp+= kernel[kernel_index] * halo_right[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
    }

    if(halo_left!=NULL){
        for(int i = 0; i < s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = s - i;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
        for(int i = s; i < nrows - s; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
        for(int i = nrows - s; i < nrows; i++){
            for(int j = 0; j < s; j++){
                k_i_start = 0;
                k_i_end = kernel_size - i + nrows - s;
                k_j_start = 0;
                k_j_end = s - j;
                tmp = 0.0;
                res_index = (i)*ncols + j;
                
                for(int k_i = k_i_start; k_i < k_i_end; k_i++){
                for(int k_j = k_j_start; k_j < k_j_end; k_j++){
                    img_index = (i  +  k_i - s)*s + (j + k_j); // (i + k_i)*ncols + (j + k_j - s)
                    kernel_index = k_i * kernel_size + k_j;  

                    tmp+= kernel[kernel_index] * halo_left[img_index];   

                    }

                }
                res[res_index] += tmp;


            }
        }
    }





}



int main(int argc, char**argv){
    
    if(argc < 3){
        printf("usage: \n ./executable KERNEL_TYPE<0,1,..> KERNEL_SIZE INPUT_FILE \n ---PGM FILES ALLOWED ONLY--- \n");
        return 0;
    }
    int myid, numprocs;
    int tag = 123;
    int master = 0;
    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD,&numprocs);
    MPI_Comm_rank(MPI_COMM_WORLD,&myid); 
    MPI_Request request;
    MPI_Status status;
    //get the id
    
    
    //each process needs his own kernel 

    unsigned short int kernel_type;
    unsigned int kernel_size;
    double* kernel;
    char* input_file, *out_file; 

    kernel_type = atoi(argv[1]);
    kernel_size = atoi(argv[2]);

    if(kernel_size%2 == 0){
        if (myid==0) printf("Please insert an odd kernel size!\n");
        MPI_Finalize();
        return 0;
    }
    input_file = argv[argc - 2];
    out_file = "out.pgm";
    if (argc > 4){out_file = argv[argc - 1];}
    kernel = (double*)malloc(kernel_size*kernel_size*sizeof(double));
    switch (kernel_type){
        case 0:
        //mean kernel
        get_MEAN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected MEAN kernel \n");
        break;

        case 1:
        {
        double w = atof(argv[3]);
        get_WEIGHT_kernel(kernel,kernel_size,w);
        if (I_AM_MASTER)  printf("Selected WEIGHT kernel \n");
        break;
        }

        case 2:

        //gaussian kernel
        get_GAUSSIAN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected GAUSSIAN kernel \n");
        break;

        case 3:
        //sharpen kernel
        kernel_size = 3;
        free(kernel);
        kernel = (double*)malloc(kernel_size*kernel_size*sizeof(double));
        get_SHARPEN_kernel(kernel,kernel_size);
        if (I_AM_MASTER)  printf("Selected SHARPEN kernel \n ATTENTION FOR THIS KERNEL kernel_size BOUDNED TO 3 \n");
        break;


        default:
        if(myid == 0){
        printf("Unknown kernel\nThis is the list of Implemented kernels: \n");
        printf("0 --> Mean Kernel \n");
        printf("1 --> Weight Kernel \n");
        printf("2 --> Gaussian Kernel \n");
        printf("3 --> Sharpening Kernel \n");
        printf("+ others will be added developement\n");
        }
        MPI_Finalize();
        return 0;

    }

    ////printf("---KERNEL---\n");
    //print_kernel(kernel,kernel_size);
    
    void* source;
    int maxval, nrows, ncols;
    int metadata[3];
    int s = kernel_size/2;
    if(I_AM_MASTER){
    printf("%s\n", input_file);
      read_pgm_image(&source, &maxval, &ncols, &nrows, input_file);
      if ( I_M_LITTLE_ENDIAN ) swap_image( source, ncols, nrows, maxval);
      metadata[0] = maxval;
      metadata[1] = ncols;
      metadata[2] = nrows;
      printf("File opened, processing %d Bytes image\n", 1 + (maxval > 255) );

    }

    MPI_Bcast(metadata,3, MPI_INT, 0, MPI_COMM_WORLD);
    maxval = metadata[0];
    ncols = metadata[1];
    nrows = metadata[2];



    int tot_dims[2];
    tot_dims[0] = nrows;
    tot_dims[1] = ncols;
    int grid_dims[2] = {0,0};
    int reorder = 0;
    int periodicity[2] = {0,0};

    MPI_Comm grid_comm;
    MPI_Dims_create(numprocs, 2, grid_dims);
    MPI_Cart_create(MPI_COMM_WORLD, 2, grid_dims, periodicity, reorder, &grid_comm);
    
    int grid_coords[2] = {0,0};
    int grid_rank;


    MPI_Comm_rank(grid_comm, &grid_rank);
    MPI_Cart_coords(grid_comm, grid_rank, 2 , grid_coords);
    

    switch(1+(maxval > 255)){
      case 1:
      {
        
        if(I_AM_MASTER){
            unsigned char* bf_to_send = (unsigned char*)source;
            unsigned char* final_res = (unsigned char*)malloc(nrows*ncols*sizeof(unsigned char));
            for(int p = 0; p < numprocs; p++){
            
                int recv_coords[2];
                MPI_Cart_coords(grid_comm, p, 2 , recv_coords);
            
                int sub_mat_sizes[2], start_point[2];
                sub_matrix_dim(nrows, ncols, grid_dims, recv_coords, sub_mat_sizes, start_point);
                MPI_Datatype chunk;
                
                MPI_Type_create_subarray(2, tot_dims, sub_mat_sizes, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &chunk);
                MPI_Type_commit(&chunk);
                MPI_Isend(bf_to_send, 1, chunk, p, tag, grid_comm, &request);
                MPI_Type_free(&chunk);


            
          }
        
        unsigned char* HALOS[4] = {NULL, NULL, NULL, NULL};
        unsigned char* QQ[4] = {NULL, NULL, NULL, NULL};
        int sub_mat_sizes[2], start_point[2];
            
            
        sub_matrix_dim(nrows, ncols, grid_dims, grid_coords, sub_mat_sizes, start_point);
        int len = sub_mat_sizes[0]*sub_mat_sizes[1];
        unsigned char* my_img = (unsigned char *)malloc(len*sizeof(unsigned char*));
        unsigned char* my_res = (unsigned char *)malloc(len*sizeof(unsigned char*));


        MPI_Recv(my_img, len, MPI_UNSIGNED_CHAR, 0, tag, grid_comm, &status);
        exchange_halos_1B(my_img, sub_mat_sizes, HALOS, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm );
        exchange_Q_1B(my_img, sub_mat_sizes, QQ, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm);
        ////printf("%d %d sub_mat_sizes\n", sub_mat_sizes[0], sub_mat_sizes[1]);
        convolve_1B(my_img, sub_mat_sizes[0], sub_mat_sizes[1], kernel, kernel_size, my_res);
        halo_convolve_1B(HALOS, sub_mat_sizes, kernel, kernel_size, my_res);
        //QQ_convolve_1B(QQ, HALOS, sub_mat_sizes, kernel, kernel_size, my_res);

        MPI_Isend(my_res, len, MPI_UNSIGNED_CHAR, 0, tag, grid_comm, &request);

        for(int p = 0; p < numprocs; p++){
            
                int recv_coords[2];
                MPI_Cart_coords(grid_comm, p, 2 , recv_coords);
            
                int sub_mat_sizes[2], start_point[2];
                sub_matrix_dim(nrows, ncols, grid_dims, recv_coords, sub_mat_sizes, start_point);
                MPI_Datatype chunk;
                
                MPI_Type_create_subarray(2, tot_dims, sub_mat_sizes, start_point, MPI_ORDER_C, MPI_UNSIGNED_CHAR, &chunk);
                MPI_Type_commit(&chunk);
                MPI_Recv(final_res, 1, chunk, p, tag, grid_comm, &status);
                MPI_Type_free(&chunk);
          }

        if ( I_M_LITTLE_ENDIAN ) swap_image( final_res, ncols, nrows, maxval);
        write_pgm_image(final_res, maxval,ncols, nrows, out_file);
        //write_pgm_image(HALOS[1], maxval, s, sub_mat_sizes[0], out_file);
        ////printf("%p %p %p %p\n", QQ[0], QQ[1], QQ[2], QQ[3]);
       
        }
        

        else{
            int grid_coords[2];
            MPI_Cart_coords(grid_comm, grid_rank, 2 , grid_coords);
            int sub_mat_sizes[2], start_point[2];
            
            
            sub_matrix_dim(nrows, ncols, grid_dims, grid_coords, sub_mat_sizes, start_point);
            int len = sub_mat_sizes[0]*sub_mat_sizes[1];
            
            unsigned char* my_img =(unsigned char*) malloc(len*sizeof(unsigned char));
            unsigned char* res =(unsigned char*) malloc(len*sizeof(unsigned char));
            MPI_Recv(my_img, len, MPI_UNSIGNED_CHAR, 0, tag, grid_comm, &status);
            unsigned char* HALOS[4];
            HALOS[0] = NULL;
            HALOS[1] = NULL;
            HALOS[2] = NULL;
            HALOS[3] = NULL;
            exchange_halos_1B(my_img, sub_mat_sizes, HALOS, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm );
            
            unsigned char* QQ[4] = {NULL, NULL, NULL, NULL};
            exchange_Q_1B(my_img, sub_mat_sizes, QQ, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm);
            
            convolve_1B(my_img, sub_mat_sizes[0], sub_mat_sizes[1], kernel, kernel_size, res);
            halo_convolve_1B(HALOS, sub_mat_sizes, kernel, kernel_size, res);
            //printf("sq %d %p %p %p %p\n",grid_rank, QQ[0], QQ[1], QQ[2], QQ[3]);
            ////printf("halo %d %p %p %p %p\n",grid_rank, HALOS[0], HALOS[1], HALOS[2], HALOS[3]);
            QQ_convolve_1B(QQ, HALOS, sub_mat_sizes, kernel, kernel_size, res);
            MPI_Send(res, len, MPI_UNSIGNED_CHAR, 0, tag, grid_comm);

            ////printf("%d %d %d %d \n", grid_coords[0], grid_coords[1], sub_mat_sizes[0], sub_mat_sizes[1]);
            //if (grid_rank == 2) write_pgm_image(HALOS[1], maxval,s,sub_mat_sizes[0],  "cc.pgm");

          
        }
        
        break;
      }
      
      case 2:
      {


        
        if(I_AM_MASTER){
            unsigned short* bf_to_send = (unsigned short*)source;
            unsigned short* final_res = (unsigned short*)malloc(nrows*ncols*sizeof(unsigned short));
            for(int p = 0; p < numprocs; p++){
            
                int recv_coords[2];
                MPI_Cart_coords(grid_comm, p, 2 , recv_coords);
            
                int sub_mat_sizes[2], start_point[2];
                sub_matrix_dim(nrows, ncols, grid_dims, recv_coords, sub_mat_sizes, start_point);
                MPI_Datatype chunk;
                
                MPI_Type_create_subarray(2, tot_dims, sub_mat_sizes, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &chunk);
                MPI_Type_commit(&chunk);
                MPI_Isend(bf_to_send, 1, chunk, p, tag, grid_comm, &request);
                MPI_Type_free(&chunk);


            
          }
        
        unsigned short* HALOS[4] = {NULL, NULL, NULL, NULL};
        unsigned short* QQ[4] = {NULL, NULL, NULL, NULL};
        int sub_mat_sizes[2], start_point[2];
            
            
        sub_matrix_dim(nrows, ncols, grid_dims, grid_coords, sub_mat_sizes, start_point);
        int len = sub_mat_sizes[0]*sub_mat_sizes[1];
        unsigned short* my_img = (unsigned short *)malloc(len*sizeof(unsigned short*));
        unsigned short* my_res = (unsigned short *)malloc(len*sizeof(unsigned short*));


        MPI_Recv(my_img, len, MPI_UNSIGNED_SHORT, 0, tag, grid_comm, &status);
        exchange_halos_2B(my_img, sub_mat_sizes, HALOS, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm );
        exchange_Q_2B(my_img, sub_mat_sizes, QQ, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm);
        ////printf("%d %d sub_mat_sizes\n", sub_mat_sizes[0], sub_mat_sizes[1]);
        convolve_2B(my_img, sub_mat_sizes[0], sub_mat_sizes[1], kernel, kernel_size, my_res);
        halo_convolve_2B(HALOS, sub_mat_sizes, kernel, kernel_size, my_res);
        //QQ_convolve_1B(QQ, HALOS, sub_mat_sizes, kernel, kernel_size, my_res);

        MPI_Isend(my_res, len, MPI_UNSIGNED_SHORT, 0, tag, grid_comm, &request);

        for(int p = 0; p < numprocs; p++){
            
                int recv_coords[2];
                MPI_Cart_coords(grid_comm, p, 2 , recv_coords);
            
                int sub_mat_sizes[2], start_point[2];
                sub_matrix_dim(nrows, ncols, grid_dims, recv_coords, sub_mat_sizes, start_point);
                MPI_Datatype chunk;
                
                MPI_Type_create_subarray(2, tot_dims, sub_mat_sizes, start_point, MPI_ORDER_C, MPI_UNSIGNED_SHORT, &chunk);
                MPI_Type_commit(&chunk);
                MPI_Recv(final_res, 1, chunk, p, tag, grid_comm, &status);
                MPI_Type_free(&chunk);
          }

        if ( I_M_LITTLE_ENDIAN ) swap_image( final_res, ncols, nrows, maxval);
        write_pgm_image(final_res, maxval,ncols, nrows, out_file);
        //write_pgm_image(HALOS[1], maxval, s, sub_mat_sizes[0], out_file);
        ////printf("%p %p %p %p\n", QQ[0], QQ[1], QQ[2], QQ[3]);
       
        }
        

        else{
            int grid_coords[2];
            MPI_Cart_coords(grid_comm, grid_rank, 2 , grid_coords);
            int sub_mat_sizes[2], start_point[2];
            
            
            sub_matrix_dim(nrows, ncols, grid_dims, grid_coords, sub_mat_sizes, start_point);
            int len = sub_mat_sizes[0]*sub_mat_sizes[1];
            
            unsigned short* my_img =(unsigned short*) malloc(len*sizeof(unsigned short));
            unsigned short* res =(unsigned short*) malloc(len*sizeof(unsigned short));
            MPI_Recv(my_img, len, MPI_UNSIGNED_SHORT, 0, tag, grid_comm, &status);
            unsigned short* HALOS[4];
            HALOS[0] = NULL;
            HALOS[1] = NULL;
            HALOS[2] = NULL;
            HALOS[3] = NULL;
            exchange_halos_2B(my_img, sub_mat_sizes, HALOS, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm );
            
            unsigned short* QQ[4] = {NULL, NULL, NULL, NULL};
            exchange_Q_2B(my_img, sub_mat_sizes, QQ, grid_dims, grid_rank, grid_coords, kernel_size, grid_comm);
            
            convolve_2B(my_img, sub_mat_sizes[0], sub_mat_sizes[1], kernel, kernel_size, res);
            halo_convolve_2B(HALOS, sub_mat_sizes, kernel, kernel_size, res);
            //printf("sq %d %p %p %p %p\n",grid_rank, QQ[0], QQ[1], QQ[2], QQ[3]);
            ////printf("halo %d %p %p %p %p\n",grid_rank, HALOS[0], HALOS[1], HALOS[2], HALOS[3]);
            QQ_convolve_2B(QQ, HALOS, sub_mat_sizes, kernel, kernel_size, res);
            MPI_Send(res, len, MPI_UNSIGNED_SHORT, 0, tag, grid_comm);

            ////printf("%d %d %d %d \n", grid_coords[0], grid_coords[1], sub_mat_sizes[0], sub_mat_sizes[1]);
            //if (grid_rank == 2) write_pgm_image(HALOS[1], maxval,s,sub_mat_sizes[0],  "cc.pgm");
        }
      }
          
    }  
    free(kernel);
    //free(source);
    MPI_Finalize();
    return 0;
    
}


